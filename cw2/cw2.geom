#version 410 

// We are using triangles for the input and triangle_strip for the output
//Also specify the maximum number of vertices expected to be generated by the shader
layout(triangles) in;
layout(triangle_strip, max_vertices = 72) out;

uniform mat4 mvMatrix;
uniform mat4 pMatrix;
uniform mat3 normalMatrix; //mv matrix without translation

uniform vec4 lightPosition_camSpace; //light Position in camera space

uniform int time;
uniform int level;


float alpha;
float beta;
float gamma;


in data
{
  vec4 position_camSpace;
  vec3 normal_camSpace;
  vec2 textureCoordinate;
  vec4 color;
}vertexIn[3];

out fragmentData
{
  vec4 position_camSpace;
  vec3 normal_camSpace;
  vec2 textureCoordinate;
  vec4 color;
} frag;

/*
//Compute alpha, beta and gamma for (x,y)
void calculateBC() {
	vec2 p1 = gl_in[0].gl_Position.xy;
	vec2 p2 = gl_in[1].gl_Position.xy;
	vec2 p3 = gl_in[2].gl_Position.xy;
	vec2 v1 = p2 - p1;
	vec2 v2 = p3 - p1;
	vec2 v3 = p3 - p1;
	beta = sqrt(pow((p2.x - p1.x), 2) + pow((p2.y - p1.y), 2)) / 2;
	gamma = sqrt(pow((p3.x - p1.x), 2) + pow((p3.y - p1.y), 2)) / 2;
	alpha = 1 - beta - gamma;
//area of a triangle is 1/2|(xa - xc)(yb - ya) - (xa-xb)(yc-ya)|
//	float area = (1/2) * abs((p1.x-p3.x)*(p2.y-p1.y) - (p1.x-p2.x)(p3.y-p1.y));
}
*/


void generateVertex(float a, float b, float g){
    gl_Position = a * gl_in[0].gl_Position
				 + b * gl_in[1].gl_Position
				 + g * gl_in[2].gl_Position;
    frag.position_camSpace = a * vertexIn[0].position_camSpace
							 + b * vertexIn[1].position_camSpace
							 + g * vertexIn[2].position_camSpace;
    frag.normal_camSpace = a * vertexIn[0].normal_camSpace
						 + b * vertexIn[1].normal_camSpace
						 + g * vertexIn[2].normal_camSpace;
    frag.textureCoordinate = a * vertexIn[0].textureCoordinate
							 + b * vertexIn[1].textureCoordinate
							 + g * vertexIn[2].textureCoordinate;
    frag.color = a * vertexIn[0].color
				 + b * vertexIn[1].color
				 + g * vertexIn[2].color;
	EmitVertex();
	
}

void calculateOutmost(vec3 top, int cut){
	
	float delta = 1 / float(int(pow(2, level)));
	float a = top.x;
	float b = top.y;
	float g = top.z;
	generateVertex(a, b, g);
	for (int j = 1; j <= cut; j++){
	//Calculate the leftdownward slope
	  generateVertex(a+delta, b, g-delta);
	//Calculate the rightHorizontal line
	  vec3 right = vec3(a, b+delta, g-delta);
	  generateVertex(right.x, right.y, right.z);
	  top = right;
	}
    EndPrimitive(); //Tell shader we are done producing vercies for current primitive
/*
	for (int i = 0; i < pow(2, level)-1; i++){
      generateVertex(a+(1/delta), b+(i*((1/delta))),  (g-(1/delta))-(i*(1/delta)));
	  generateVertex(a, (b+(1/delta))+(i*((1/delta))), (g-(1/delta))-(i*(1/delta)));
	}
	EndPrimitive();  
*/

}

void main() {
// In this loop, we are generating vertices by copying elements of gl_in[] to the geometry shader's output
// EmitVertex() is a built-in func specific to geometry shaders, tells the shader that we are done with this vertex and hence should store all information away
/*
  for (int i = 0; i < 3; i++) { // You used triangles, so it's always 3
    gl_Position = gl_in[i].gl_Position;
    frag.position_camSpace = vertexIn[i].position_camSpace;
    frag.normal_camSpace = vertexIn[i].normal_camSpace;
    frag.textureCoordinate = vertexIn[i].textureCoordinate;
    frag.color = vertexIn[i].color;
	EmitVertex();
  }
*/


  vec3 top = vec3(0.0, 0.0, 1.0);
  int maxVer = int(pow(2, level));
  float delta = 1/ float(maxVer);
  for (int i = maxVer; i > 0; i--){
	calculateOutmost(top, i);
	float a = top.x;
	float b = top.y;
	float g = top.z;
	top = vec3(a+delta, b, g-delta);
  }
  

 }










